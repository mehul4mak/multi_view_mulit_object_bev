// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_schema_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_schema_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_schema_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_schema_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_schema_2eproto;
namespace nv {
class AnalyticsModule;
struct AnalyticsModuleDefaultTypeInternal;
extern AnalyticsModuleDefaultTypeInternal _AnalyticsModule_default_instance_;
class AnalyticsModule_InfoEntry_DoNotUse;
struct AnalyticsModule_InfoEntry_DoNotUseDefaultTypeInternal;
extern AnalyticsModule_InfoEntry_DoNotUseDefaultTypeInternal _AnalyticsModule_InfoEntry_DoNotUse_default_instance_;
class Bbox;
struct BboxDefaultTypeInternal;
extern BboxDefaultTypeInternal _Bbox_default_instance_;
class Coordinate;
struct CoordinateDefaultTypeInternal;
extern CoordinateDefaultTypeInternal _Coordinate_default_instance_;
class Embedding;
struct EmbeddingDefaultTypeInternal;
extern EmbeddingDefaultTypeInternal _Embedding_default_instance_;
class Embedding_InfoEntry_DoNotUse;
struct Embedding_InfoEntry_DoNotUseDefaultTypeInternal;
extern Embedding_InfoEntry_DoNotUseDefaultTypeInternal _Embedding_InfoEntry_DoNotUse_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_InfoEntry_DoNotUse;
struct Event_InfoEntry_DoNotUseDefaultTypeInternal;
extern Event_InfoEntry_DoNotUseDefaultTypeInternal _Event_InfoEntry_DoNotUse_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class Gaze;
struct GazeDefaultTypeInternal;
extern GazeDefaultTypeInternal _Gaze_default_instance_;
class LipActivity;
struct LipActivityDefaultTypeInternal;
extern LipActivityDefaultTypeInternal _LipActivity_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_InfoEntry_DoNotUse;
struct Object_InfoEntry_DoNotUseDefaultTypeInternal;
extern Object_InfoEntry_DoNotUseDefaultTypeInternal _Object_InfoEntry_DoNotUse_default_instance_;
class Place;
struct PlaceDefaultTypeInternal;
extern PlaceDefaultTypeInternal _Place_default_instance_;
class Place_InfoEntry_DoNotUse;
struct Place_InfoEntry_DoNotUseDefaultTypeInternal;
extern Place_InfoEntry_DoNotUseDefaultTypeInternal _Place_InfoEntry_DoNotUse_default_instance_;
class Pose;
struct PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Pose_Action;
struct Pose_ActionDefaultTypeInternal;
extern Pose_ActionDefaultTypeInternal _Pose_Action_default_instance_;
class Pose_Keypoint;
struct Pose_KeypointDefaultTypeInternal;
extern Pose_KeypointDefaultTypeInternal _Pose_Keypoint_default_instance_;
class Sensor;
struct SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class Sensor_InfoEntry_DoNotUse;
struct Sensor_InfoEntry_DoNotUseDefaultTypeInternal;
extern Sensor_InfoEntry_DoNotUseDefaultTypeInternal _Sensor_InfoEntry_DoNotUse_default_instance_;
}  // namespace nv
PROTOBUF_NAMESPACE_OPEN
template<> ::nv::AnalyticsModule* Arena::CreateMaybeMessage<::nv::AnalyticsModule>(Arena*);
template<> ::nv::AnalyticsModule_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::AnalyticsModule_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Bbox* Arena::CreateMaybeMessage<::nv::Bbox>(Arena*);
template<> ::nv::Coordinate* Arena::CreateMaybeMessage<::nv::Coordinate>(Arena*);
template<> ::nv::Embedding* Arena::CreateMaybeMessage<::nv::Embedding>(Arena*);
template<> ::nv::Embedding_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Embedding_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Event* Arena::CreateMaybeMessage<::nv::Event>(Arena*);
template<> ::nv::Event_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Event_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Frame* Arena::CreateMaybeMessage<::nv::Frame>(Arena*);
template<> ::nv::Gaze* Arena::CreateMaybeMessage<::nv::Gaze>(Arena*);
template<> ::nv::LipActivity* Arena::CreateMaybeMessage<::nv::LipActivity>(Arena*);
template<> ::nv::Location* Arena::CreateMaybeMessage<::nv::Location>(Arena*);
template<> ::nv::Message* Arena::CreateMaybeMessage<::nv::Message>(Arena*);
template<> ::nv::Object* Arena::CreateMaybeMessage<::nv::Object>(Arena*);
template<> ::nv::Object_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Object_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Place* Arena::CreateMaybeMessage<::nv::Place>(Arena*);
template<> ::nv::Place_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Place_InfoEntry_DoNotUse>(Arena*);
template<> ::nv::Pose* Arena::CreateMaybeMessage<::nv::Pose>(Arena*);
template<> ::nv::Pose_Action* Arena::CreateMaybeMessage<::nv::Pose_Action>(Arena*);
template<> ::nv::Pose_Keypoint* Arena::CreateMaybeMessage<::nv::Pose_Keypoint>(Arena*);
template<> ::nv::Sensor* Arena::CreateMaybeMessage<::nv::Sensor>(Arena*);
template<> ::nv::Sensor_InfoEntry_DoNotUse* Arena::CreateMaybeMessage<::nv::Sensor_InfoEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nv {

// ===================================================================

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 5,
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kSensorIdFieldNumber = 4,
    kTimestampFieldNumber = 3,
  };
  // repeated .nv.Object objects = 5;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::nv::Object* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Object >*
      mutable_objects();
  private:
  const ::nv::Object& _internal_objects(int index) const;
  ::nv::Object* _internal_add_objects();
  public:
  const ::nv::Object& objects(int index) const;
  ::nv::Object* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Object >&
      objects() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string sensorId = 4;
  void clear_sensorid();
  const std::string& sensorid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensorid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensorid();
  PROTOBUF_NODISCARD std::string* release_sensorid();
  void set_allocated_sensorid(std::string* sensorid);
  private:
  const std::string& _internal_sensorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensorid(const std::string& value);
  std::string* _internal_mutable_sensorid();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:nv.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Object > objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensorid_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Object_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Object_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Object_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Object_InfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Object_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Object_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Object_InfoEntry_DoNotUse& other);
  static const Object_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Object_InfoEntry_DoNotUse*>(&_Object_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Object.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Object.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};

// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit PROTOBUF_CONSTEXPR Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Object& from) {
    Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 5,
    kDirFieldNumber = 11,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 3,
    kBboxFieldNumber = 2,
    kEmbeddingFieldNumber = 6,
    kPoseFieldNumber = 7,
    kGazeFieldNumber = 8,
    kLipActivityFieldNumber = 9,
    kCoordinateFieldNumber = 12,
    kLocationFieldNumber = 13,
    kConfidenceFieldNumber = 4,
    kSpeedFieldNumber = 10,
  };
  // map<string, string> info = 5;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // repeated float dir = 11;
  int dir_size() const;
  private:
  int _internal_dir_size() const;
  public:
  void clear_dir();
  private:
  float _internal_dir(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_dir() const;
  void _internal_add_dir(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_dir();
  public:
  float dir(int index) const;
  void set_dir(int index, float value);
  void add_dir(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      dir() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_dir();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .nv.Bbox bbox = 2;
  bool has_bbox() const;
  private:
  bool _internal_has_bbox() const;
  public:
  void clear_bbox();
  const ::nv::Bbox& bbox() const;
  PROTOBUF_NODISCARD ::nv::Bbox* release_bbox();
  ::nv::Bbox* mutable_bbox();
  void set_allocated_bbox(::nv::Bbox* bbox);
  private:
  const ::nv::Bbox& _internal_bbox() const;
  ::nv::Bbox* _internal_mutable_bbox();
  public:
  void unsafe_arena_set_allocated_bbox(
      ::nv::Bbox* bbox);
  ::nv::Bbox* unsafe_arena_release_bbox();

  // .nv.Embedding embedding = 6;
  bool has_embedding() const;
  private:
  bool _internal_has_embedding() const;
  public:
  void clear_embedding();
  const ::nv::Embedding& embedding() const;
  PROTOBUF_NODISCARD ::nv::Embedding* release_embedding();
  ::nv::Embedding* mutable_embedding();
  void set_allocated_embedding(::nv::Embedding* embedding);
  private:
  const ::nv::Embedding& _internal_embedding() const;
  ::nv::Embedding* _internal_mutable_embedding();
  public:
  void unsafe_arena_set_allocated_embedding(
      ::nv::Embedding* embedding);
  ::nv::Embedding* unsafe_arena_release_embedding();

  // .nv.Pose pose = 7;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::nv::Pose& pose() const;
  PROTOBUF_NODISCARD ::nv::Pose* release_pose();
  ::nv::Pose* mutable_pose();
  void set_allocated_pose(::nv::Pose* pose);
  private:
  const ::nv::Pose& _internal_pose() const;
  ::nv::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::nv::Pose* pose);
  ::nv::Pose* unsafe_arena_release_pose();

  // .nv.Gaze gaze = 8;
  bool has_gaze() const;
  private:
  bool _internal_has_gaze() const;
  public:
  void clear_gaze();
  const ::nv::Gaze& gaze() const;
  PROTOBUF_NODISCARD ::nv::Gaze* release_gaze();
  ::nv::Gaze* mutable_gaze();
  void set_allocated_gaze(::nv::Gaze* gaze);
  private:
  const ::nv::Gaze& _internal_gaze() const;
  ::nv::Gaze* _internal_mutable_gaze();
  public:
  void unsafe_arena_set_allocated_gaze(
      ::nv::Gaze* gaze);
  ::nv::Gaze* unsafe_arena_release_gaze();

  // .nv.LipActivity lipActivity = 9;
  bool has_lipactivity() const;
  private:
  bool _internal_has_lipactivity() const;
  public:
  void clear_lipactivity();
  const ::nv::LipActivity& lipactivity() const;
  PROTOBUF_NODISCARD ::nv::LipActivity* release_lipactivity();
  ::nv::LipActivity* mutable_lipactivity();
  void set_allocated_lipactivity(::nv::LipActivity* lipactivity);
  private:
  const ::nv::LipActivity& _internal_lipactivity() const;
  ::nv::LipActivity* _internal_mutable_lipactivity();
  public:
  void unsafe_arena_set_allocated_lipactivity(
      ::nv::LipActivity* lipactivity);
  ::nv::LipActivity* unsafe_arena_release_lipactivity();

  // .nv.Coordinate coordinate = 12;
  bool has_coordinate() const;
  private:
  bool _internal_has_coordinate() const;
  public:
  void clear_coordinate();
  const ::nv::Coordinate& coordinate() const;
  PROTOBUF_NODISCARD ::nv::Coordinate* release_coordinate();
  ::nv::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::nv::Coordinate* coordinate);
  private:
  const ::nv::Coordinate& _internal_coordinate() const;
  ::nv::Coordinate* _internal_mutable_coordinate();
  public:
  void unsafe_arena_set_allocated_coordinate(
      ::nv::Coordinate* coordinate);
  ::nv::Coordinate* unsafe_arena_release_coordinate();

  // .nv.Location location = 13;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::nv::Location& location() const;
  PROTOBUF_NODISCARD ::nv::Location* release_location();
  ::nv::Location* mutable_location();
  void set_allocated_location(::nv::Location* location);
  private:
  const ::nv::Location& _internal_location() const;
  ::nv::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::nv::Location* location);
  ::nv::Location* unsafe_arena_release_location();

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // float speed = 10;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:nv.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Object_InfoEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > dir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::nv::Bbox* bbox_;
    ::nv::Embedding* embedding_;
    ::nv::Pose* pose_;
    ::nv::Gaze* gaze_;
    ::nv::LipActivity* lipactivity_;
    ::nv::Coordinate* coordinate_;
    ::nv::Location* location_;
    float confidence_;
    float speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Coordinate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Coordinate) */ {
 public:
  inline Coordinate() : Coordinate(nullptr) {}
  ~Coordinate() override;
  explicit PROTOBUF_CONSTEXPR Coordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Coordinate(const Coordinate& from);
  Coordinate(Coordinate&& from) noexcept
    : Coordinate() {
    *this = ::std::move(from);
  }

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coordinate& operator=(Coordinate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Coordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Coordinate* internal_default_instance() {
    return reinterpret_cast<const Coordinate*>(
               &_Coordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Coordinate& a, Coordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(Coordinate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Coordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Coordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Coordinate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Coordinate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Coordinate& from) {
    Coordinate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coordinate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Coordinate";
  }
  protected:
  explicit Coordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:nv.Coordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit PROTOBUF_CONSTEXPR Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Location& from) {
    Location::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kAltFieldNumber = 3,
  };
  // double lat = 1;
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // double lon = 2;
  void clear_lon();
  double lon() const;
  void set_lon(double value);
  private:
  double _internal_lon() const;
  void _internal_set_lon(double value);
  public:

  // double alt = 3;
  void clear_alt();
  double alt() const;
  void set_alt(double value);
  private:
  double _internal_alt() const;
  void _internal_set_alt(double value);
  public:

  // @@protoc_insertion_point(class_scope:nv.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double lat_;
    double lon_;
    double alt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Bbox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Bbox) */ {
 public:
  inline Bbox() : Bbox(nullptr) {}
  ~Bbox() override;
  explicit PROTOBUF_CONSTEXPR Bbox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bbox(const Bbox& from);
  Bbox(Bbox&& from) noexcept
    : Bbox() {
    *this = ::std::move(from);
  }

  inline Bbox& operator=(const Bbox& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bbox& operator=(Bbox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bbox& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bbox* internal_default_instance() {
    return reinterpret_cast<const Bbox*>(
               &_Bbox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Bbox& a, Bbox& b) {
    a.Swap(&b);
  }
  inline void Swap(Bbox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bbox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bbox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bbox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bbox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bbox& from) {
    Bbox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bbox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Bbox";
  }
  protected:
  explicit Bbox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftXFieldNumber = 1,
    kTopYFieldNumber = 2,
    kRightXFieldNumber = 3,
    kBottomYFieldNumber = 4,
  };
  // float leftX = 1;
  void clear_leftx();
  float leftx() const;
  void set_leftx(float value);
  private:
  float _internal_leftx() const;
  void _internal_set_leftx(float value);
  public:

  // float topY = 2;
  void clear_topy();
  float topy() const;
  void set_topy(float value);
  private:
  float _internal_topy() const;
  void _internal_set_topy(float value);
  public:

  // float rightX = 3;
  void clear_rightx();
  float rightx() const;
  void set_rightx(float value);
  private:
  float _internal_rightx() const;
  void _internal_set_rightx(float value);
  public:

  // float bottomY = 4;
  void clear_bottomy();
  float bottomy() const;
  void set_bottomy(float value);
  private:
  float _internal_bottomy() const;
  void _internal_set_bottomy(float value);
  public:

  // @@protoc_insertion_point(class_scope:nv.Bbox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float leftx_;
    float topy_;
    float rightx_;
    float bottomy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Pose_Keypoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Pose.Keypoint) */ {
 public:
  inline Pose_Keypoint() : Pose_Keypoint(nullptr) {}
  ~Pose_Keypoint() override;
  explicit PROTOBUF_CONSTEXPR Pose_Keypoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pose_Keypoint(const Pose_Keypoint& from);
  Pose_Keypoint(Pose_Keypoint&& from) noexcept
    : Pose_Keypoint() {
    *this = ::std::move(from);
  }

  inline Pose_Keypoint& operator=(const Pose_Keypoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose_Keypoint& operator=(Pose_Keypoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose_Keypoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose_Keypoint* internal_default_instance() {
    return reinterpret_cast<const Pose_Keypoint*>(
               &_Pose_Keypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Pose_Keypoint& a, Pose_Keypoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose_Keypoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose_Keypoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose_Keypoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose_Keypoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pose_Keypoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pose_Keypoint& from) {
    Pose_Keypoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose_Keypoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Pose.Keypoint";
  }
  protected:
  explicit Pose_Keypoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordinatesFieldNumber = 2,
    kQuaternionFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated float coordinates = 2;
  int coordinates_size() const;
  private:
  int _internal_coordinates_size() const;
  public:
  void clear_coordinates();
  private:
  float _internal_coordinates(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_coordinates() const;
  void _internal_add_coordinates(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_coordinates();
  public:
  float coordinates(int index) const;
  void set_coordinates(int index, float value);
  void add_coordinates(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      coordinates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_coordinates();

  // repeated float quaternion = 3;
  int quaternion_size() const;
  private:
  int _internal_quaternion_size() const;
  public:
  void clear_quaternion();
  private:
  float _internal_quaternion(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_quaternion() const;
  void _internal_add_quaternion(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_quaternion();
  public:
  float quaternion(int index) const;
  void set_quaternion(int index, float value);
  void add_quaternion(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      quaternion() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_quaternion();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:nv.Pose.Keypoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > coordinates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > quaternion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Pose_Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Pose.Action) */ {
 public:
  inline Pose_Action() : Pose_Action(nullptr) {}
  ~Pose_Action() override;
  explicit PROTOBUF_CONSTEXPR Pose_Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pose_Action(const Pose_Action& from);
  Pose_Action(Pose_Action&& from) noexcept
    : Pose_Action() {
    *this = ::std::move(from);
  }

  inline Pose_Action& operator=(const Pose_Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose_Action& operator=(Pose_Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose_Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose_Action* internal_default_instance() {
    return reinterpret_cast<const Pose_Action*>(
               &_Pose_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Pose_Action& a, Pose_Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose_Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose_Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose_Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose_Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pose_Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pose_Action& from) {
    Pose_Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose_Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Pose.Action";
  }
  protected:
  explicit Pose_Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // float confidence = 2;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:nv.Pose.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {}
  ~Pose() override;
  explicit PROTOBUF_CONSTEXPR Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pose& from) {
    Pose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Pose_Keypoint Keypoint;
  typedef Pose_Action Action;

  // accessors -------------------------------------------------------

  enum : int {
    kKeypointsFieldNumber = 2,
    kActionsFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated .nv.Pose.Keypoint keypoints = 2;
  int keypoints_size() const;
  private:
  int _internal_keypoints_size() const;
  public:
  void clear_keypoints();
  ::nv::Pose_Keypoint* mutable_keypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Keypoint >*
      mutable_keypoints();
  private:
  const ::nv::Pose_Keypoint& _internal_keypoints(int index) const;
  ::nv::Pose_Keypoint* _internal_add_keypoints();
  public:
  const ::nv::Pose_Keypoint& keypoints(int index) const;
  ::nv::Pose_Keypoint* add_keypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Keypoint >&
      keypoints() const;

  // repeated .nv.Pose.Action actions = 3;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::nv::Pose_Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Action >*
      mutable_actions();
  private:
  const ::nv::Pose_Action& _internal_actions(int index) const;
  ::nv::Pose_Action* _internal_add_actions();
  public:
  const ::nv::Pose_Action& actions(int index) const;
  ::nv::Pose_Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Action >&
      actions() const;

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:nv.Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Keypoint > keypoints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Action > actions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Gaze final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Gaze) */ {
 public:
  inline Gaze() : Gaze(nullptr) {}
  ~Gaze() override;
  explicit PROTOBUF_CONSTEXPR Gaze(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gaze(const Gaze& from);
  Gaze(Gaze&& from) noexcept
    : Gaze() {
    *this = ::std::move(from);
  }

  inline Gaze& operator=(const Gaze& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gaze& operator=(Gaze&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gaze& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gaze* internal_default_instance() {
    return reinterpret_cast<const Gaze*>(
               &_Gaze_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Gaze& a, Gaze& b) {
    a.Swap(&b);
  }
  inline void Swap(Gaze* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gaze* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gaze* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gaze>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gaze& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gaze& from) {
    Gaze::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gaze* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Gaze";
  }
  protected:
  explicit Gaze(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kThetaFieldNumber = 4,
    kPhiFieldNumber = 5,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float theta = 4;
  void clear_theta();
  float theta() const;
  void set_theta(float value);
  private:
  float _internal_theta() const;
  void _internal_set_theta(float value);
  public:

  // float phi = 5;
  void clear_phi();
  float phi() const;
  void set_phi(float value);
  private:
  float _internal_phi() const;
  void _internal_set_phi(float value);
  public:

  // @@protoc_insertion_point(class_scope:nv.Gaze)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    float theta_;
    float phi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class LipActivity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.LipActivity) */ {
 public:
  inline LipActivity() : LipActivity(nullptr) {}
  ~LipActivity() override;
  explicit PROTOBUF_CONSTEXPR LipActivity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LipActivity(const LipActivity& from);
  LipActivity(LipActivity&& from) noexcept
    : LipActivity() {
    *this = ::std::move(from);
  }

  inline LipActivity& operator=(const LipActivity& from) {
    CopyFrom(from);
    return *this;
  }
  inline LipActivity& operator=(LipActivity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LipActivity& default_instance() {
    return *internal_default_instance();
  }
  static inline const LipActivity* internal_default_instance() {
    return reinterpret_cast<const LipActivity*>(
               &_LipActivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LipActivity& a, LipActivity& b) {
    a.Swap(&b);
  }
  inline void Swap(LipActivity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LipActivity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LipActivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LipActivity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LipActivity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LipActivity& from) {
    LipActivity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LipActivity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.LipActivity";
  }
  protected:
  explicit LipActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassLabelFieldNumber = 1,
  };
  // string classLabel = 1;
  void clear_classlabel();
  const std::string& classlabel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classlabel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classlabel();
  PROTOBUF_NODISCARD std::string* release_classlabel();
  void set_allocated_classlabel(std::string* classlabel);
  private:
  const std::string& _internal_classlabel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classlabel(const std::string& value);
  std::string* _internal_mutable_classlabel();
  public:

  // @@protoc_insertion_point(class_scope:nv.LipActivity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classlabel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Event_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Event_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Event_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Event_InfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Event_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Event_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Event_InfoEntry_DoNotUse& other);
  static const Event_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Event_InfoEntry_DoNotUse*>(&_Event_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Event.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Event.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};

// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 5,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // map<string, string> info = 5;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:nv.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Event_InfoEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class AnalyticsModule_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AnalyticsModule_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AnalyticsModule_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AnalyticsModule_InfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AnalyticsModule_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AnalyticsModule_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AnalyticsModule_InfoEntry_DoNotUse& other);
  static const AnalyticsModule_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AnalyticsModule_InfoEntry_DoNotUse*>(&_AnalyticsModule_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.AnalyticsModule.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.AnalyticsModule.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};

// -------------------------------------------------------------------

class AnalyticsModule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.AnalyticsModule) */ {
 public:
  inline AnalyticsModule() : AnalyticsModule(nullptr) {}
  ~AnalyticsModule() override;
  explicit PROTOBUF_CONSTEXPR AnalyticsModule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalyticsModule(const AnalyticsModule& from);
  AnalyticsModule(AnalyticsModule&& from) noexcept
    : AnalyticsModule() {
    *this = ::std::move(from);
  }

  inline AnalyticsModule& operator=(const AnalyticsModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyticsModule& operator=(AnalyticsModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyticsModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyticsModule* internal_default_instance() {
    return reinterpret_cast<const AnalyticsModule*>(
               &_AnalyticsModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AnalyticsModule& a, AnalyticsModule& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyticsModule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyticsModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyticsModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyticsModule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalyticsModule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnalyticsModule& from) {
    AnalyticsModule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalyticsModule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.AnalyticsModule";
  }
  protected:
  explicit AnalyticsModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 5,
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kSourceFieldNumber = 3,
    kVersionFieldNumber = 4,
  };
  // map<string, string> info = 5;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string version = 4;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:nv.AnalyticsModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AnalyticsModule_InfoEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Sensor_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Sensor_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Sensor_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Sensor_InfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Sensor_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Sensor_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Sensor_InfoEntry_DoNotUse& other);
  static const Sensor_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Sensor_InfoEntry_DoNotUse*>(&_Sensor_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Sensor.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Sensor.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};

// -------------------------------------------------------------------

class Sensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Sensor) */ {
 public:
  inline Sensor() : Sensor(nullptr) {}
  ~Sensor() override;
  explicit PROTOBUF_CONSTEXPR Sensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sensor(const Sensor& from);
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor& operator=(Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Sensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sensor& from) {
    Sensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Sensor";
  }
  protected:
  explicit Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 6,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kLocationFieldNumber = 4,
    kCoordinateFieldNumber = 5,
  };
  // map<string, string> info = 6;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .nv.Location location = 4;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::nv::Location& location() const;
  PROTOBUF_NODISCARD ::nv::Location* release_location();
  ::nv::Location* mutable_location();
  void set_allocated_location(::nv::Location* location);
  private:
  const ::nv::Location& _internal_location() const;
  ::nv::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::nv::Location* location);
  ::nv::Location* unsafe_arena_release_location();

  // .nv.Coordinate coordinate = 5;
  bool has_coordinate() const;
  private:
  bool _internal_has_coordinate() const;
  public:
  void clear_coordinate();
  const ::nv::Coordinate& coordinate() const;
  PROTOBUF_NODISCARD ::nv::Coordinate* release_coordinate();
  ::nv::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::nv::Coordinate* coordinate);
  private:
  const ::nv::Coordinate& _internal_coordinate() const;
  ::nv::Coordinate* _internal_mutable_coordinate();
  public:
  void unsafe_arena_set_allocated_coordinate(
      ::nv::Coordinate* coordinate);
  ::nv::Coordinate* unsafe_arena_release_coordinate();

  // @@protoc_insertion_point(class_scope:nv.Sensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Sensor_InfoEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::nv::Location* location_;
    ::nv::Coordinate* coordinate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Place_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Place_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Place_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Place_InfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Place_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Place_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Place_InfoEntry_DoNotUse& other);
  static const Place_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Place_InfoEntry_DoNotUse*>(&_Place_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Place.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Place.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};

// -------------------------------------------------------------------

class Place final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Place) */ {
 public:
  inline Place() : Place(nullptr) {}
  ~Place() override;
  explicit PROTOBUF_CONSTEXPR Place(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Place(const Place& from);
  Place(Place&& from) noexcept
    : Place() {
    *this = ::std::move(from);
  }

  inline Place& operator=(const Place& from) {
    CopyFrom(from);
    return *this;
  }
  inline Place& operator=(Place&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Place& default_instance() {
    return *internal_default_instance();
  }
  static inline const Place* internal_default_instance() {
    return reinterpret_cast<const Place*>(
               &_Place_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Place& a, Place& b) {
    a.Swap(&b);
  }
  inline void Swap(Place* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Place* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Place* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Place>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Place& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Place& from) {
    Place::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Place* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Place";
  }
  protected:
  explicit Place(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 6,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kLocationFieldNumber = 4,
    kCoordinateFieldNumber = 5,
  };
  // map<string, string> info = 6;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .nv.Location location = 4;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::nv::Location& location() const;
  PROTOBUF_NODISCARD ::nv::Location* release_location();
  ::nv::Location* mutable_location();
  void set_allocated_location(::nv::Location* location);
  private:
  const ::nv::Location& _internal_location() const;
  ::nv::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::nv::Location* location);
  ::nv::Location* unsafe_arena_release_location();

  // .nv.Coordinate coordinate = 5;
  bool has_coordinate() const;
  private:
  bool _internal_has_coordinate() const;
  public:
  void clear_coordinate();
  const ::nv::Coordinate& coordinate() const;
  PROTOBUF_NODISCARD ::nv::Coordinate* release_coordinate();
  ::nv::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::nv::Coordinate* coordinate);
  private:
  const ::nv::Coordinate& _internal_coordinate() const;
  ::nv::Coordinate* _internal_mutable_coordinate();
  public:
  void unsafe_arena_set_allocated_coordinate(
      ::nv::Coordinate* coordinate);
  ::nv::Coordinate* unsafe_arena_release_coordinate();

  // @@protoc_insertion_point(class_scope:nv.Place)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Place_InfoEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::nv::Location* location_;
    ::nv::Coordinate* coordinate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageidFieldNumber = 1,
    kMdsversionFieldNumber = 2,
    kVideoPathFieldNumber = 9,
    kTimestampFieldNumber = 3,
    kPlaceFieldNumber = 4,
    kSensorFieldNumber = 5,
    kAnalyticsModuleFieldNumber = 6,
    kObjectFieldNumber = 7,
    kEventFieldNumber = 8,
  };
  // string messageid = 1;
  void clear_messageid();
  const std::string& messageid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_messageid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_messageid();
  PROTOBUF_NODISCARD std::string* release_messageid();
  void set_allocated_messageid(std::string* messageid);
  private:
  const std::string& _internal_messageid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messageid(const std::string& value);
  std::string* _internal_mutable_messageid();
  public:

  // string mdsversion = 2;
  void clear_mdsversion();
  const std::string& mdsversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mdsversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mdsversion();
  PROTOBUF_NODISCARD std::string* release_mdsversion();
  void set_allocated_mdsversion(std::string* mdsversion);
  private:
  const std::string& _internal_mdsversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mdsversion(const std::string& value);
  std::string* _internal_mutable_mdsversion();
  public:

  // string videoPath = 9;
  void clear_videopath();
  const std::string& videopath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_videopath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_videopath();
  PROTOBUF_NODISCARD std::string* release_videopath();
  void set_allocated_videopath(std::string* videopath);
  private:
  const std::string& _internal_videopath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_videopath(const std::string& value);
  std::string* _internal_mutable_videopath();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .nv.Place place = 4;
  bool has_place() const;
  private:
  bool _internal_has_place() const;
  public:
  void clear_place();
  const ::nv::Place& place() const;
  PROTOBUF_NODISCARD ::nv::Place* release_place();
  ::nv::Place* mutable_place();
  void set_allocated_place(::nv::Place* place);
  private:
  const ::nv::Place& _internal_place() const;
  ::nv::Place* _internal_mutable_place();
  public:
  void unsafe_arena_set_allocated_place(
      ::nv::Place* place);
  ::nv::Place* unsafe_arena_release_place();

  // .nv.Sensor sensor = 5;
  bool has_sensor() const;
  private:
  bool _internal_has_sensor() const;
  public:
  void clear_sensor();
  const ::nv::Sensor& sensor() const;
  PROTOBUF_NODISCARD ::nv::Sensor* release_sensor();
  ::nv::Sensor* mutable_sensor();
  void set_allocated_sensor(::nv::Sensor* sensor);
  private:
  const ::nv::Sensor& _internal_sensor() const;
  ::nv::Sensor* _internal_mutable_sensor();
  public:
  void unsafe_arena_set_allocated_sensor(
      ::nv::Sensor* sensor);
  ::nv::Sensor* unsafe_arena_release_sensor();

  // .nv.AnalyticsModule analyticsModule = 6;
  bool has_analyticsmodule() const;
  private:
  bool _internal_has_analyticsmodule() const;
  public:
  void clear_analyticsmodule();
  const ::nv::AnalyticsModule& analyticsmodule() const;
  PROTOBUF_NODISCARD ::nv::AnalyticsModule* release_analyticsmodule();
  ::nv::AnalyticsModule* mutable_analyticsmodule();
  void set_allocated_analyticsmodule(::nv::AnalyticsModule* analyticsmodule);
  private:
  const ::nv::AnalyticsModule& _internal_analyticsmodule() const;
  ::nv::AnalyticsModule* _internal_mutable_analyticsmodule();
  public:
  void unsafe_arena_set_allocated_analyticsmodule(
      ::nv::AnalyticsModule* analyticsmodule);
  ::nv::AnalyticsModule* unsafe_arena_release_analyticsmodule();

  // .nv.Object object = 7;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::nv::Object& object() const;
  PROTOBUF_NODISCARD ::nv::Object* release_object();
  ::nv::Object* mutable_object();
  void set_allocated_object(::nv::Object* object);
  private:
  const ::nv::Object& _internal_object() const;
  ::nv::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::nv::Object* object);
  ::nv::Object* unsafe_arena_release_object();

  // .nv.Event event = 8;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::nv::Event& event() const;
  PROTOBUF_NODISCARD ::nv::Event* release_event();
  ::nv::Event* mutable_event();
  void set_allocated_event(::nv::Event* event);
  private:
  const ::nv::Event& _internal_event() const;
  ::nv::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::nv::Event* event);
  ::nv::Event* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:nv.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messageid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mdsversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr videopath_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::nv::Place* place_;
    ::nv::Sensor* sensor_;
    ::nv::AnalyticsModule* analyticsmodule_;
    ::nv::Object* object_;
    ::nv::Event* event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// -------------------------------------------------------------------

class Embedding_InfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Embedding_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Embedding_InfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Embedding_InfoEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Embedding_InfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Embedding_InfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Embedding_InfoEntry_DoNotUse& other);
  static const Embedding_InfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Embedding_InfoEntry_DoNotUse*>(&_Embedding_InfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Embedding.InfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nv.Embedding.InfoEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_schema_2eproto;
};

// -------------------------------------------------------------------

class Embedding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nv.Embedding) */ {
 public:
  inline Embedding() : Embedding(nullptr) {}
  ~Embedding() override;
  explicit PROTOBUF_CONSTEXPR Embedding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Embedding(const Embedding& from);
  Embedding(Embedding&& from) noexcept
    : Embedding() {
    *this = ::std::move(from);
  }

  inline Embedding& operator=(const Embedding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Embedding& operator=(Embedding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Embedding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Embedding* internal_default_instance() {
    return reinterpret_cast<const Embedding*>(
               &_Embedding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Embedding& a, Embedding& b) {
    a.Swap(&b);
  }
  inline void Swap(Embedding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Embedding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Embedding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Embedding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Embedding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Embedding& from) {
    Embedding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Embedding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nv.Embedding";
  }
  protected:
  explicit Embedding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // repeated float vector = 1 [packed = true];
  int vector_size() const;
  private:
  int _internal_vector_size() const;
  public:
  void clear_vector();
  private:
  float _internal_vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_vector() const;
  void _internal_add_vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_vector();
  public:
  float vector(int index) const;
  void set_vector(int index, float value);
  void add_vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_vector();

  // map<string, string> info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_info();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      info() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:nv.Embedding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > vector_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Embedding_InfoEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Frame

// string version = 1;
inline void Frame::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Frame::version() const {
  // @@protoc_insertion_point(field_get:nv.Frame.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Frame.version)
}
inline std::string* Frame::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:nv.Frame.version)
  return _s;
}
inline const std::string& Frame::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Frame::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_version() {
  // @@protoc_insertion_point(field_release:nv.Frame.version)
  return _impl_.version_.Release();
}
inline void Frame::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.version)
}

// string id = 2;
inline void Frame::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Frame::id() const {
  // @@protoc_insertion_point(field_get:nv.Frame.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Frame.id)
}
inline std::string* Frame::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nv.Frame.id)
  return _s;
}
inline const std::string& Frame::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Frame::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_id() {
  // @@protoc_insertion_point(field_release:nv.Frame.id)
  return _impl_.id_.Release();
}
inline void Frame::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.id)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool Frame::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Frame::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Frame::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Frame::timestamp() const {
  // @@protoc_insertion_point(field_get:nv.Frame.timestamp)
  return _internal_timestamp();
}
inline void Frame::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Frame.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Frame::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Frame::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:nv.Frame.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Frame::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Frame::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:nv.Frame.timestamp)
  return _msg;
}
inline void Frame::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.timestamp)
}

// string sensorId = 4;
inline void Frame::clear_sensorid() {
  _impl_.sensorid_.ClearToEmpty();
}
inline const std::string& Frame::sensorid() const {
  // @@protoc_insertion_point(field_get:nv.Frame.sensorId)
  return _internal_sensorid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_sensorid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sensorid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Frame.sensorId)
}
inline std::string* Frame::mutable_sensorid() {
  std::string* _s = _internal_mutable_sensorid();
  // @@protoc_insertion_point(field_mutable:nv.Frame.sensorId)
  return _s;
}
inline const std::string& Frame::_internal_sensorid() const {
  return _impl_.sensorid_.Get();
}
inline void Frame::_internal_set_sensorid(const std::string& value) {
  
  _impl_.sensorid_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_sensorid() {
  
  return _impl_.sensorid_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_sensorid() {
  // @@protoc_insertion_point(field_release:nv.Frame.sensorId)
  return _impl_.sensorid_.Release();
}
inline void Frame::set_allocated_sensorid(std::string* sensorid) {
  if (sensorid != nullptr) {
    
  } else {
    
  }
  _impl_.sensorid_.SetAllocated(sensorid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensorid_.IsDefault()) {
    _impl_.sensorid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Frame.sensorId)
}

// repeated .nv.Object objects = 5;
inline int Frame::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int Frame::objects_size() const {
  return _internal_objects_size();
}
inline void Frame::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::nv::Object* Frame::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:nv.Frame.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Object >*
Frame::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:nv.Frame.objects)
  return &_impl_.objects_;
}
inline const ::nv::Object& Frame::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::nv::Object& Frame::objects(int index) const {
  // @@protoc_insertion_point(field_get:nv.Frame.objects)
  return _internal_objects(index);
}
inline ::nv::Object* Frame::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::nv::Object* Frame::add_objects() {
  ::nv::Object* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:nv.Frame.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Object >&
Frame::objects() const {
  // @@protoc_insertion_point(field_list:nv.Frame.objects)
  return _impl_.objects_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Object

// string id = 1;
inline void Object::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:nv.Object.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Object.id)
}
inline std::string* Object::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nv.Object.id)
  return _s;
}
inline const std::string& Object::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Object::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:nv.Object.id)
  return _impl_.id_.Release();
}
inline void Object::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Object.id)
}

// .nv.Bbox bbox = 2;
inline bool Object::_internal_has_bbox() const {
  return this != internal_default_instance() && _impl_.bbox_ != nullptr;
}
inline bool Object::has_bbox() const {
  return _internal_has_bbox();
}
inline void Object::clear_bbox() {
  if (GetArenaForAllocation() == nullptr && _impl_.bbox_ != nullptr) {
    delete _impl_.bbox_;
  }
  _impl_.bbox_ = nullptr;
}
inline const ::nv::Bbox& Object::_internal_bbox() const {
  const ::nv::Bbox* p = _impl_.bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Bbox&>(
      ::nv::_Bbox_default_instance_);
}
inline const ::nv::Bbox& Object::bbox() const {
  // @@protoc_insertion_point(field_get:nv.Object.bbox)
  return _internal_bbox();
}
inline void Object::unsafe_arena_set_allocated_bbox(
    ::nv::Bbox* bbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bbox_);
  }
  _impl_.bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.bbox)
}
inline ::nv::Bbox* Object::release_bbox() {
  
  ::nv::Bbox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Bbox* Object::unsafe_arena_release_bbox() {
  // @@protoc_insertion_point(field_release:nv.Object.bbox)
  
  ::nv::Bbox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
  return temp;
}
inline ::nv::Bbox* Object::_internal_mutable_bbox() {
  
  if (_impl_.bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Bbox>(GetArenaForAllocation());
    _impl_.bbox_ = p;
  }
  return _impl_.bbox_;
}
inline ::nv::Bbox* Object::mutable_bbox() {
  ::nv::Bbox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:nv.Object.bbox)
  return _msg;
}
inline void Object::set_allocated_bbox(::nv::Bbox* bbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bbox_;
  }
  if (bbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bbox);
    if (message_arena != submessage_arena) {
      bbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.bbox)
}

// string type = 3;
inline void Object::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Object::type() const {
  // @@protoc_insertion_point(field_get:nv.Object.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Object.type)
}
inline std::string* Object::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:nv.Object.type)
  return _s;
}
inline const std::string& Object::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Object::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Object::release_type() {
  // @@protoc_insertion_point(field_release:nv.Object.type)
  return _impl_.type_.Release();
}
inline void Object::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Object.type)
}

// float confidence = 4;
inline void Object::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float Object::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float Object::confidence() const {
  // @@protoc_insertion_point(field_get:nv.Object.confidence)
  return _internal_confidence();
}
inline void Object::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void Object::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:nv.Object.confidence)
}

// map<string, string> info = 5;
inline int Object::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Object::info_size() const {
  return _internal_info_size();
}
inline void Object::clear_info() {
  _impl_.info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Object::_internal_info() const {
  return _impl_.info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Object::info() const {
  // @@protoc_insertion_point(field_map:nv.Object.info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Object::_internal_mutable_info() {
  return _impl_.info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Object::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Object.info)
  return _internal_mutable_info();
}

// .nv.Embedding embedding = 6;
inline bool Object::_internal_has_embedding() const {
  return this != internal_default_instance() && _impl_.embedding_ != nullptr;
}
inline bool Object::has_embedding() const {
  return _internal_has_embedding();
}
inline void Object::clear_embedding() {
  if (GetArenaForAllocation() == nullptr && _impl_.embedding_ != nullptr) {
    delete _impl_.embedding_;
  }
  _impl_.embedding_ = nullptr;
}
inline const ::nv::Embedding& Object::_internal_embedding() const {
  const ::nv::Embedding* p = _impl_.embedding_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Embedding&>(
      ::nv::_Embedding_default_instance_);
}
inline const ::nv::Embedding& Object::embedding() const {
  // @@protoc_insertion_point(field_get:nv.Object.embedding)
  return _internal_embedding();
}
inline void Object::unsafe_arena_set_allocated_embedding(
    ::nv::Embedding* embedding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.embedding_);
  }
  _impl_.embedding_ = embedding;
  if (embedding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.embedding)
}
inline ::nv::Embedding* Object::release_embedding() {
  
  ::nv::Embedding* temp = _impl_.embedding_;
  _impl_.embedding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Embedding* Object::unsafe_arena_release_embedding() {
  // @@protoc_insertion_point(field_release:nv.Object.embedding)
  
  ::nv::Embedding* temp = _impl_.embedding_;
  _impl_.embedding_ = nullptr;
  return temp;
}
inline ::nv::Embedding* Object::_internal_mutable_embedding() {
  
  if (_impl_.embedding_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Embedding>(GetArenaForAllocation());
    _impl_.embedding_ = p;
  }
  return _impl_.embedding_;
}
inline ::nv::Embedding* Object::mutable_embedding() {
  ::nv::Embedding* _msg = _internal_mutable_embedding();
  // @@protoc_insertion_point(field_mutable:nv.Object.embedding)
  return _msg;
}
inline void Object::set_allocated_embedding(::nv::Embedding* embedding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.embedding_;
  }
  if (embedding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(embedding);
    if (message_arena != submessage_arena) {
      embedding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, embedding, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.embedding_ = embedding;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.embedding)
}

// .nv.Pose pose = 7;
inline bool Object::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool Object::has_pose() const {
  return _internal_has_pose();
}
inline void Object::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
inline const ::nv::Pose& Object::_internal_pose() const {
  const ::nv::Pose* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Pose&>(
      ::nv::_Pose_default_instance_);
}
inline const ::nv::Pose& Object::pose() const {
  // @@protoc_insertion_point(field_get:nv.Object.pose)
  return _internal_pose();
}
inline void Object::unsafe_arena_set_allocated_pose(
    ::nv::Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.pose)
}
inline ::nv::Pose* Object::release_pose() {
  
  ::nv::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Pose* Object::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:nv.Object.pose)
  
  ::nv::Pose* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::nv::Pose* Object::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Pose>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::nv::Pose* Object::mutable_pose() {
  ::nv::Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:nv.Object.pose)
  return _msg;
}
inline void Object::set_allocated_pose(::nv::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.pose)
}

// .nv.Gaze gaze = 8;
inline bool Object::_internal_has_gaze() const {
  return this != internal_default_instance() && _impl_.gaze_ != nullptr;
}
inline bool Object::has_gaze() const {
  return _internal_has_gaze();
}
inline void Object::clear_gaze() {
  if (GetArenaForAllocation() == nullptr && _impl_.gaze_ != nullptr) {
    delete _impl_.gaze_;
  }
  _impl_.gaze_ = nullptr;
}
inline const ::nv::Gaze& Object::_internal_gaze() const {
  const ::nv::Gaze* p = _impl_.gaze_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Gaze&>(
      ::nv::_Gaze_default_instance_);
}
inline const ::nv::Gaze& Object::gaze() const {
  // @@protoc_insertion_point(field_get:nv.Object.gaze)
  return _internal_gaze();
}
inline void Object::unsafe_arena_set_allocated_gaze(
    ::nv::Gaze* gaze) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gaze_);
  }
  _impl_.gaze_ = gaze;
  if (gaze) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.gaze)
}
inline ::nv::Gaze* Object::release_gaze() {
  
  ::nv::Gaze* temp = _impl_.gaze_;
  _impl_.gaze_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Gaze* Object::unsafe_arena_release_gaze() {
  // @@protoc_insertion_point(field_release:nv.Object.gaze)
  
  ::nv::Gaze* temp = _impl_.gaze_;
  _impl_.gaze_ = nullptr;
  return temp;
}
inline ::nv::Gaze* Object::_internal_mutable_gaze() {
  
  if (_impl_.gaze_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Gaze>(GetArenaForAllocation());
    _impl_.gaze_ = p;
  }
  return _impl_.gaze_;
}
inline ::nv::Gaze* Object::mutable_gaze() {
  ::nv::Gaze* _msg = _internal_mutable_gaze();
  // @@protoc_insertion_point(field_mutable:nv.Object.gaze)
  return _msg;
}
inline void Object::set_allocated_gaze(::nv::Gaze* gaze) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gaze_;
  }
  if (gaze) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gaze);
    if (message_arena != submessage_arena) {
      gaze = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gaze, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gaze_ = gaze;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.gaze)
}

// .nv.LipActivity lipActivity = 9;
inline bool Object::_internal_has_lipactivity() const {
  return this != internal_default_instance() && _impl_.lipactivity_ != nullptr;
}
inline bool Object::has_lipactivity() const {
  return _internal_has_lipactivity();
}
inline void Object::clear_lipactivity() {
  if (GetArenaForAllocation() == nullptr && _impl_.lipactivity_ != nullptr) {
    delete _impl_.lipactivity_;
  }
  _impl_.lipactivity_ = nullptr;
}
inline const ::nv::LipActivity& Object::_internal_lipactivity() const {
  const ::nv::LipActivity* p = _impl_.lipactivity_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::LipActivity&>(
      ::nv::_LipActivity_default_instance_);
}
inline const ::nv::LipActivity& Object::lipactivity() const {
  // @@protoc_insertion_point(field_get:nv.Object.lipActivity)
  return _internal_lipactivity();
}
inline void Object::unsafe_arena_set_allocated_lipactivity(
    ::nv::LipActivity* lipactivity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lipactivity_);
  }
  _impl_.lipactivity_ = lipactivity;
  if (lipactivity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.lipActivity)
}
inline ::nv::LipActivity* Object::release_lipactivity() {
  
  ::nv::LipActivity* temp = _impl_.lipactivity_;
  _impl_.lipactivity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::LipActivity* Object::unsafe_arena_release_lipactivity() {
  // @@protoc_insertion_point(field_release:nv.Object.lipActivity)
  
  ::nv::LipActivity* temp = _impl_.lipactivity_;
  _impl_.lipactivity_ = nullptr;
  return temp;
}
inline ::nv::LipActivity* Object::_internal_mutable_lipactivity() {
  
  if (_impl_.lipactivity_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::LipActivity>(GetArenaForAllocation());
    _impl_.lipactivity_ = p;
  }
  return _impl_.lipactivity_;
}
inline ::nv::LipActivity* Object::mutable_lipactivity() {
  ::nv::LipActivity* _msg = _internal_mutable_lipactivity();
  // @@protoc_insertion_point(field_mutable:nv.Object.lipActivity)
  return _msg;
}
inline void Object::set_allocated_lipactivity(::nv::LipActivity* lipactivity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lipactivity_;
  }
  if (lipactivity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lipactivity);
    if (message_arena != submessage_arena) {
      lipactivity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lipactivity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lipactivity_ = lipactivity;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.lipActivity)
}

// float speed = 10;
inline void Object::clear_speed() {
  _impl_.speed_ = 0;
}
inline float Object::_internal_speed() const {
  return _impl_.speed_;
}
inline float Object::speed() const {
  // @@protoc_insertion_point(field_get:nv.Object.speed)
  return _internal_speed();
}
inline void Object::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void Object::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:nv.Object.speed)
}

// repeated float dir = 11;
inline int Object::_internal_dir_size() const {
  return _impl_.dir_.size();
}
inline int Object::dir_size() const {
  return _internal_dir_size();
}
inline void Object::clear_dir() {
  _impl_.dir_.Clear();
}
inline float Object::_internal_dir(int index) const {
  return _impl_.dir_.Get(index);
}
inline float Object::dir(int index) const {
  // @@protoc_insertion_point(field_get:nv.Object.dir)
  return _internal_dir(index);
}
inline void Object::set_dir(int index, float value) {
  _impl_.dir_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Object.dir)
}
inline void Object::_internal_add_dir(float value) {
  _impl_.dir_.Add(value);
}
inline void Object::add_dir(float value) {
  _internal_add_dir(value);
  // @@protoc_insertion_point(field_add:nv.Object.dir)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Object::_internal_dir() const {
  return _impl_.dir_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Object::dir() const {
  // @@protoc_insertion_point(field_list:nv.Object.dir)
  return _internal_dir();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Object::_internal_mutable_dir() {
  return &_impl_.dir_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Object::mutable_dir() {
  // @@protoc_insertion_point(field_mutable_list:nv.Object.dir)
  return _internal_mutable_dir();
}

// .nv.Coordinate coordinate = 12;
inline bool Object::_internal_has_coordinate() const {
  return this != internal_default_instance() && _impl_.coordinate_ != nullptr;
}
inline bool Object::has_coordinate() const {
  return _internal_has_coordinate();
}
inline void Object::clear_coordinate() {
  if (GetArenaForAllocation() == nullptr && _impl_.coordinate_ != nullptr) {
    delete _impl_.coordinate_;
  }
  _impl_.coordinate_ = nullptr;
}
inline const ::nv::Coordinate& Object::_internal_coordinate() const {
  const ::nv::Coordinate* p = _impl_.coordinate_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Coordinate&>(
      ::nv::_Coordinate_default_instance_);
}
inline const ::nv::Coordinate& Object::coordinate() const {
  // @@protoc_insertion_point(field_get:nv.Object.coordinate)
  return _internal_coordinate();
}
inline void Object::unsafe_arena_set_allocated_coordinate(
    ::nv::Coordinate* coordinate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coordinate_);
  }
  _impl_.coordinate_ = coordinate;
  if (coordinate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.coordinate)
}
inline ::nv::Coordinate* Object::release_coordinate() {
  
  ::nv::Coordinate* temp = _impl_.coordinate_;
  _impl_.coordinate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Coordinate* Object::unsafe_arena_release_coordinate() {
  // @@protoc_insertion_point(field_release:nv.Object.coordinate)
  
  ::nv::Coordinate* temp = _impl_.coordinate_;
  _impl_.coordinate_ = nullptr;
  return temp;
}
inline ::nv::Coordinate* Object::_internal_mutable_coordinate() {
  
  if (_impl_.coordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Coordinate>(GetArenaForAllocation());
    _impl_.coordinate_ = p;
  }
  return _impl_.coordinate_;
}
inline ::nv::Coordinate* Object::mutable_coordinate() {
  ::nv::Coordinate* _msg = _internal_mutable_coordinate();
  // @@protoc_insertion_point(field_mutable:nv.Object.coordinate)
  return _msg;
}
inline void Object::set_allocated_coordinate(::nv::Coordinate* coordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coordinate_;
  }
  if (coordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coordinate);
    if (message_arena != submessage_arena) {
      coordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.coordinate)
}

// .nv.Location location = 13;
inline bool Object::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool Object::has_location() const {
  return _internal_has_location();
}
inline void Object::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::nv::Location& Object::_internal_location() const {
  const ::nv::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Location&>(
      ::nv::_Location_default_instance_);
}
inline const ::nv::Location& Object::location() const {
  // @@protoc_insertion_point(field_get:nv.Object.location)
  return _internal_location();
}
inline void Object::unsafe_arena_set_allocated_location(
    ::nv::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Object.location)
}
inline ::nv::Location* Object::release_location() {
  
  ::nv::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Location* Object::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:nv.Object.location)
  
  ::nv::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::nv::Location* Object::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Location>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::nv::Location* Object::mutable_location() {
  ::nv::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:nv.Object.location)
  return _msg;
}
inline void Object::set_allocated_location(::nv::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nv.Object.location)
}

// -------------------------------------------------------------------

// Coordinate

// double x = 1;
inline void Coordinate::clear_x() {
  _impl_.x_ = 0;
}
inline double Coordinate::_internal_x() const {
  return _impl_.x_;
}
inline double Coordinate::x() const {
  // @@protoc_insertion_point(field_get:nv.Coordinate.x)
  return _internal_x();
}
inline void Coordinate::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Coordinate::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:nv.Coordinate.x)
}

// double y = 2;
inline void Coordinate::clear_y() {
  _impl_.y_ = 0;
}
inline double Coordinate::_internal_y() const {
  return _impl_.y_;
}
inline double Coordinate::y() const {
  // @@protoc_insertion_point(field_get:nv.Coordinate.y)
  return _internal_y();
}
inline void Coordinate::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Coordinate::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:nv.Coordinate.y)
}

// double z = 3;
inline void Coordinate::clear_z() {
  _impl_.z_ = 0;
}
inline double Coordinate::_internal_z() const {
  return _impl_.z_;
}
inline double Coordinate::z() const {
  // @@protoc_insertion_point(field_get:nv.Coordinate.z)
  return _internal_z();
}
inline void Coordinate::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Coordinate::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:nv.Coordinate.z)
}

// -------------------------------------------------------------------

// Location

// double lat = 1;
inline void Location::clear_lat() {
  _impl_.lat_ = 0;
}
inline double Location::_internal_lat() const {
  return _impl_.lat_;
}
inline double Location::lat() const {
  // @@protoc_insertion_point(field_get:nv.Location.lat)
  return _internal_lat();
}
inline void Location::_internal_set_lat(double value) {
  
  _impl_.lat_ = value;
}
inline void Location::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:nv.Location.lat)
}

// double lon = 2;
inline void Location::clear_lon() {
  _impl_.lon_ = 0;
}
inline double Location::_internal_lon() const {
  return _impl_.lon_;
}
inline double Location::lon() const {
  // @@protoc_insertion_point(field_get:nv.Location.lon)
  return _internal_lon();
}
inline void Location::_internal_set_lon(double value) {
  
  _impl_.lon_ = value;
}
inline void Location::set_lon(double value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:nv.Location.lon)
}

// double alt = 3;
inline void Location::clear_alt() {
  _impl_.alt_ = 0;
}
inline double Location::_internal_alt() const {
  return _impl_.alt_;
}
inline double Location::alt() const {
  // @@protoc_insertion_point(field_get:nv.Location.alt)
  return _internal_alt();
}
inline void Location::_internal_set_alt(double value) {
  
  _impl_.alt_ = value;
}
inline void Location::set_alt(double value) {
  _internal_set_alt(value);
  // @@protoc_insertion_point(field_set:nv.Location.alt)
}

// -------------------------------------------------------------------

// Bbox

// float leftX = 1;
inline void Bbox::clear_leftx() {
  _impl_.leftx_ = 0;
}
inline float Bbox::_internal_leftx() const {
  return _impl_.leftx_;
}
inline float Bbox::leftx() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.leftX)
  return _internal_leftx();
}
inline void Bbox::_internal_set_leftx(float value) {
  
  _impl_.leftx_ = value;
}
inline void Bbox::set_leftx(float value) {
  _internal_set_leftx(value);
  // @@protoc_insertion_point(field_set:nv.Bbox.leftX)
}

// float topY = 2;
inline void Bbox::clear_topy() {
  _impl_.topy_ = 0;
}
inline float Bbox::_internal_topy() const {
  return _impl_.topy_;
}
inline float Bbox::topy() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.topY)
  return _internal_topy();
}
inline void Bbox::_internal_set_topy(float value) {
  
  _impl_.topy_ = value;
}
inline void Bbox::set_topy(float value) {
  _internal_set_topy(value);
  // @@protoc_insertion_point(field_set:nv.Bbox.topY)
}

// float rightX = 3;
inline void Bbox::clear_rightx() {
  _impl_.rightx_ = 0;
}
inline float Bbox::_internal_rightx() const {
  return _impl_.rightx_;
}
inline float Bbox::rightx() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.rightX)
  return _internal_rightx();
}
inline void Bbox::_internal_set_rightx(float value) {
  
  _impl_.rightx_ = value;
}
inline void Bbox::set_rightx(float value) {
  _internal_set_rightx(value);
  // @@protoc_insertion_point(field_set:nv.Bbox.rightX)
}

// float bottomY = 4;
inline void Bbox::clear_bottomy() {
  _impl_.bottomy_ = 0;
}
inline float Bbox::_internal_bottomy() const {
  return _impl_.bottomy_;
}
inline float Bbox::bottomy() const {
  // @@protoc_insertion_point(field_get:nv.Bbox.bottomY)
  return _internal_bottomy();
}
inline void Bbox::_internal_set_bottomy(float value) {
  
  _impl_.bottomy_ = value;
}
inline void Bbox::set_bottomy(float value) {
  _internal_set_bottomy(value);
  // @@protoc_insertion_point(field_set:nv.Bbox.bottomY)
}

// -------------------------------------------------------------------

// Pose_Keypoint

// string name = 1;
inline void Pose_Keypoint::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Pose_Keypoint::name() const {
  // @@protoc_insertion_point(field_get:nv.Pose.Keypoint.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pose_Keypoint::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Pose.Keypoint.name)
}
inline std::string* Pose_Keypoint::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nv.Pose.Keypoint.name)
  return _s;
}
inline const std::string& Pose_Keypoint::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Pose_Keypoint::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Pose_Keypoint::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Pose_Keypoint::release_name() {
  // @@protoc_insertion_point(field_release:nv.Pose.Keypoint.name)
  return _impl_.name_.Release();
}
inline void Pose_Keypoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Pose.Keypoint.name)
}

// repeated float coordinates = 2;
inline int Pose_Keypoint::_internal_coordinates_size() const {
  return _impl_.coordinates_.size();
}
inline int Pose_Keypoint::coordinates_size() const {
  return _internal_coordinates_size();
}
inline void Pose_Keypoint::clear_coordinates() {
  _impl_.coordinates_.Clear();
}
inline float Pose_Keypoint::_internal_coordinates(int index) const {
  return _impl_.coordinates_.Get(index);
}
inline float Pose_Keypoint::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.Keypoint.coordinates)
  return _internal_coordinates(index);
}
inline void Pose_Keypoint::set_coordinates(int index, float value) {
  _impl_.coordinates_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Pose.Keypoint.coordinates)
}
inline void Pose_Keypoint::_internal_add_coordinates(float value) {
  _impl_.coordinates_.Add(value);
}
inline void Pose_Keypoint::add_coordinates(float value) {
  _internal_add_coordinates(value);
  // @@protoc_insertion_point(field_add:nv.Pose.Keypoint.coordinates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Pose_Keypoint::_internal_coordinates() const {
  return _impl_.coordinates_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Pose_Keypoint::coordinates() const {
  // @@protoc_insertion_point(field_list:nv.Pose.Keypoint.coordinates)
  return _internal_coordinates();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Pose_Keypoint::_internal_mutable_coordinates() {
  return &_impl_.coordinates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Pose_Keypoint::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.Keypoint.coordinates)
  return _internal_mutable_coordinates();
}

// repeated float quaternion = 3;
inline int Pose_Keypoint::_internal_quaternion_size() const {
  return _impl_.quaternion_.size();
}
inline int Pose_Keypoint::quaternion_size() const {
  return _internal_quaternion_size();
}
inline void Pose_Keypoint::clear_quaternion() {
  _impl_.quaternion_.Clear();
}
inline float Pose_Keypoint::_internal_quaternion(int index) const {
  return _impl_.quaternion_.Get(index);
}
inline float Pose_Keypoint::quaternion(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.Keypoint.quaternion)
  return _internal_quaternion(index);
}
inline void Pose_Keypoint::set_quaternion(int index, float value) {
  _impl_.quaternion_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Pose.Keypoint.quaternion)
}
inline void Pose_Keypoint::_internal_add_quaternion(float value) {
  _impl_.quaternion_.Add(value);
}
inline void Pose_Keypoint::add_quaternion(float value) {
  _internal_add_quaternion(value);
  // @@protoc_insertion_point(field_add:nv.Pose.Keypoint.quaternion)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Pose_Keypoint::_internal_quaternion() const {
  return _impl_.quaternion_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Pose_Keypoint::quaternion() const {
  // @@protoc_insertion_point(field_list:nv.Pose.Keypoint.quaternion)
  return _internal_quaternion();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Pose_Keypoint::_internal_mutable_quaternion() {
  return &_impl_.quaternion_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Pose_Keypoint::mutable_quaternion() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.Keypoint.quaternion)
  return _internal_mutable_quaternion();
}

// -------------------------------------------------------------------

// Pose_Action

// string type = 1;
inline void Pose_Action::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Pose_Action::type() const {
  // @@protoc_insertion_point(field_get:nv.Pose.Action.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pose_Action::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Pose.Action.type)
}
inline std::string* Pose_Action::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:nv.Pose.Action.type)
  return _s;
}
inline const std::string& Pose_Action::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Pose_Action::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Pose_Action::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Pose_Action::release_type() {
  // @@protoc_insertion_point(field_release:nv.Pose.Action.type)
  return _impl_.type_.Release();
}
inline void Pose_Action::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Pose.Action.type)
}

// float confidence = 2;
inline void Pose_Action::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float Pose_Action::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float Pose_Action::confidence() const {
  // @@protoc_insertion_point(field_get:nv.Pose.Action.confidence)
  return _internal_confidence();
}
inline void Pose_Action::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void Pose_Action::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:nv.Pose.Action.confidence)
}

// -------------------------------------------------------------------

// Pose

// string type = 1;
inline void Pose::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Pose::type() const {
  // @@protoc_insertion_point(field_get:nv.Pose.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pose::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Pose.type)
}
inline std::string* Pose::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:nv.Pose.type)
  return _s;
}
inline const std::string& Pose::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Pose::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Pose::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Pose::release_type() {
  // @@protoc_insertion_point(field_release:nv.Pose.type)
  return _impl_.type_.Release();
}
inline void Pose::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Pose.type)
}

// repeated .nv.Pose.Keypoint keypoints = 2;
inline int Pose::_internal_keypoints_size() const {
  return _impl_.keypoints_.size();
}
inline int Pose::keypoints_size() const {
  return _internal_keypoints_size();
}
inline void Pose::clear_keypoints() {
  _impl_.keypoints_.Clear();
}
inline ::nv::Pose_Keypoint* Pose::mutable_keypoints(int index) {
  // @@protoc_insertion_point(field_mutable:nv.Pose.keypoints)
  return _impl_.keypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Keypoint >*
Pose::mutable_keypoints() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.keypoints)
  return &_impl_.keypoints_;
}
inline const ::nv::Pose_Keypoint& Pose::_internal_keypoints(int index) const {
  return _impl_.keypoints_.Get(index);
}
inline const ::nv::Pose_Keypoint& Pose::keypoints(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.keypoints)
  return _internal_keypoints(index);
}
inline ::nv::Pose_Keypoint* Pose::_internal_add_keypoints() {
  return _impl_.keypoints_.Add();
}
inline ::nv::Pose_Keypoint* Pose::add_keypoints() {
  ::nv::Pose_Keypoint* _add = _internal_add_keypoints();
  // @@protoc_insertion_point(field_add:nv.Pose.keypoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Keypoint >&
Pose::keypoints() const {
  // @@protoc_insertion_point(field_list:nv.Pose.keypoints)
  return _impl_.keypoints_;
}

// repeated .nv.Pose.Action actions = 3;
inline int Pose::_internal_actions_size() const {
  return _impl_.actions_.size();
}
inline int Pose::actions_size() const {
  return _internal_actions_size();
}
inline void Pose::clear_actions() {
  _impl_.actions_.Clear();
}
inline ::nv::Pose_Action* Pose::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:nv.Pose.actions)
  return _impl_.actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Action >*
Pose::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:nv.Pose.actions)
  return &_impl_.actions_;
}
inline const ::nv::Pose_Action& Pose::_internal_actions(int index) const {
  return _impl_.actions_.Get(index);
}
inline const ::nv::Pose_Action& Pose::actions(int index) const {
  // @@protoc_insertion_point(field_get:nv.Pose.actions)
  return _internal_actions(index);
}
inline ::nv::Pose_Action* Pose::_internal_add_actions() {
  return _impl_.actions_.Add();
}
inline ::nv::Pose_Action* Pose::add_actions() {
  ::nv::Pose_Action* _add = _internal_add_actions();
  // @@protoc_insertion_point(field_add:nv.Pose.actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nv::Pose_Action >&
Pose::actions() const {
  // @@protoc_insertion_point(field_list:nv.Pose.actions)
  return _impl_.actions_;
}

// -------------------------------------------------------------------

// Gaze

// float x = 1;
inline void Gaze::clear_x() {
  _impl_.x_ = 0;
}
inline float Gaze::_internal_x() const {
  return _impl_.x_;
}
inline float Gaze::x() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.x)
  return _internal_x();
}
inline void Gaze::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Gaze::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:nv.Gaze.x)
}

// float y = 2;
inline void Gaze::clear_y() {
  _impl_.y_ = 0;
}
inline float Gaze::_internal_y() const {
  return _impl_.y_;
}
inline float Gaze::y() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.y)
  return _internal_y();
}
inline void Gaze::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Gaze::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:nv.Gaze.y)
}

// float z = 3;
inline void Gaze::clear_z() {
  _impl_.z_ = 0;
}
inline float Gaze::_internal_z() const {
  return _impl_.z_;
}
inline float Gaze::z() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.z)
  return _internal_z();
}
inline void Gaze::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Gaze::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:nv.Gaze.z)
}

// float theta = 4;
inline void Gaze::clear_theta() {
  _impl_.theta_ = 0;
}
inline float Gaze::_internal_theta() const {
  return _impl_.theta_;
}
inline float Gaze::theta() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.theta)
  return _internal_theta();
}
inline void Gaze::_internal_set_theta(float value) {
  
  _impl_.theta_ = value;
}
inline void Gaze::set_theta(float value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:nv.Gaze.theta)
}

// float phi = 5;
inline void Gaze::clear_phi() {
  _impl_.phi_ = 0;
}
inline float Gaze::_internal_phi() const {
  return _impl_.phi_;
}
inline float Gaze::phi() const {
  // @@protoc_insertion_point(field_get:nv.Gaze.phi)
  return _internal_phi();
}
inline void Gaze::_internal_set_phi(float value) {
  
  _impl_.phi_ = value;
}
inline void Gaze::set_phi(float value) {
  _internal_set_phi(value);
  // @@protoc_insertion_point(field_set:nv.Gaze.phi)
}

// -------------------------------------------------------------------

// LipActivity

// string classLabel = 1;
inline void LipActivity::clear_classlabel() {
  _impl_.classlabel_.ClearToEmpty();
}
inline const std::string& LipActivity::classlabel() const {
  // @@protoc_insertion_point(field_get:nv.LipActivity.classLabel)
  return _internal_classlabel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LipActivity::set_classlabel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classlabel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.LipActivity.classLabel)
}
inline std::string* LipActivity::mutable_classlabel() {
  std::string* _s = _internal_mutable_classlabel();
  // @@protoc_insertion_point(field_mutable:nv.LipActivity.classLabel)
  return _s;
}
inline const std::string& LipActivity::_internal_classlabel() const {
  return _impl_.classlabel_.Get();
}
inline void LipActivity::_internal_set_classlabel(const std::string& value) {
  
  _impl_.classlabel_.Set(value, GetArenaForAllocation());
}
inline std::string* LipActivity::_internal_mutable_classlabel() {
  
  return _impl_.classlabel_.Mutable(GetArenaForAllocation());
}
inline std::string* LipActivity::release_classlabel() {
  // @@protoc_insertion_point(field_release:nv.LipActivity.classLabel)
  return _impl_.classlabel_.Release();
}
inline void LipActivity::set_allocated_classlabel(std::string* classlabel) {
  if (classlabel != nullptr) {
    
  } else {
    
  }
  _impl_.classlabel_.SetAllocated(classlabel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classlabel_.IsDefault()) {
    _impl_.classlabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.LipActivity.classLabel)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Event

// string id = 1;
inline void Event::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Event::id() const {
  // @@protoc_insertion_point(field_get:nv.Event.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Event.id)
}
inline std::string* Event::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nv.Event.id)
  return _s;
}
inline const std::string& Event::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Event::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_id() {
  // @@protoc_insertion_point(field_release:nv.Event.id)
  return _impl_.id_.Release();
}
inline void Event::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Event.id)
}

// string type = 2;
inline void Event::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:nv.Event.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Event.type)
}
inline std::string* Event::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:nv.Event.type)
  return _s;
}
inline const std::string& Event::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:nv.Event.type)
  return _impl_.type_.Release();
}
inline void Event::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Event.type)
}

// map<string, string> info = 5;
inline int Event::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Event::info_size() const {
  return _internal_info_size();
}
inline void Event::clear_info() {
  _impl_.info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Event::_internal_info() const {
  return _impl_.info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Event::info() const {
  // @@protoc_insertion_point(field_map:nv.Event.info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Event::_internal_mutable_info() {
  return _impl_.info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Event::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Event.info)
  return _internal_mutable_info();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AnalyticsModule

// string id = 1;
inline void AnalyticsModule::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AnalyticsModule::id() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnalyticsModule::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.id)
}
inline std::string* AnalyticsModule::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.id)
  return _s;
}
inline const std::string& AnalyticsModule::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AnalyticsModule::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnalyticsModule::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnalyticsModule::release_id() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.id)
  return _impl_.id_.Release();
}
inline void AnalyticsModule::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.id)
}

// string description = 2;
inline void AnalyticsModule::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AnalyticsModule::description() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnalyticsModule::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.description)
}
inline std::string* AnalyticsModule::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.description)
  return _s;
}
inline const std::string& AnalyticsModule::_internal_description() const {
  return _impl_.description_.Get();
}
inline void AnalyticsModule::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* AnalyticsModule::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* AnalyticsModule::release_description() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.description)
  return _impl_.description_.Release();
}
inline void AnalyticsModule::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.description)
}

// string source = 3;
inline void AnalyticsModule::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& AnalyticsModule::source() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnalyticsModule::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.source)
}
inline std::string* AnalyticsModule::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.source)
  return _s;
}
inline const std::string& AnalyticsModule::_internal_source() const {
  return _impl_.source_.Get();
}
inline void AnalyticsModule::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* AnalyticsModule::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* AnalyticsModule::release_source() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.source)
  return _impl_.source_.Release();
}
inline void AnalyticsModule::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.source)
}

// string version = 4;
inline void AnalyticsModule::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& AnalyticsModule::version() const {
  // @@protoc_insertion_point(field_get:nv.AnalyticsModule.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnalyticsModule::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.AnalyticsModule.version)
}
inline std::string* AnalyticsModule::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:nv.AnalyticsModule.version)
  return _s;
}
inline const std::string& AnalyticsModule::_internal_version() const {
  return _impl_.version_.Get();
}
inline void AnalyticsModule::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* AnalyticsModule::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* AnalyticsModule::release_version() {
  // @@protoc_insertion_point(field_release:nv.AnalyticsModule.version)
  return _impl_.version_.Release();
}
inline void AnalyticsModule::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.AnalyticsModule.version)
}

// map<string, string> info = 5;
inline int AnalyticsModule::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int AnalyticsModule::info_size() const {
  return _internal_info_size();
}
inline void AnalyticsModule::clear_info() {
  _impl_.info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AnalyticsModule::_internal_info() const {
  return _impl_.info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AnalyticsModule::info() const {
  // @@protoc_insertion_point(field_map:nv.AnalyticsModule.info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AnalyticsModule::_internal_mutable_info() {
  return _impl_.info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AnalyticsModule::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.AnalyticsModule.info)
  return _internal_mutable_info();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Sensor

// string id = 1;
inline void Sensor::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Sensor::id() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Sensor.id)
}
inline std::string* Sensor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nv.Sensor.id)
  return _s;
}
inline const std::string& Sensor::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Sensor::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Sensor::release_id() {
  // @@protoc_insertion_point(field_release:nv.Sensor.id)
  return _impl_.id_.Release();
}
inline void Sensor::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.id)
}

// string type = 2;
inline void Sensor::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Sensor::type() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Sensor.type)
}
inline std::string* Sensor::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:nv.Sensor.type)
  return _s;
}
inline const std::string& Sensor::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Sensor::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Sensor::release_type() {
  // @@protoc_insertion_point(field_release:nv.Sensor.type)
  return _impl_.type_.Release();
}
inline void Sensor::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.type)
}

// string description = 3;
inline void Sensor::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Sensor::description() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sensor::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Sensor.description)
}
inline std::string* Sensor::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:nv.Sensor.description)
  return _s;
}
inline const std::string& Sensor::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Sensor::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Sensor::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Sensor::release_description() {
  // @@protoc_insertion_point(field_release:nv.Sensor.description)
  return _impl_.description_.Release();
}
inline void Sensor::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.description)
}

// .nv.Location location = 4;
inline bool Sensor::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool Sensor::has_location() const {
  return _internal_has_location();
}
inline void Sensor::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::nv::Location& Sensor::_internal_location() const {
  const ::nv::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Location&>(
      ::nv::_Location_default_instance_);
}
inline const ::nv::Location& Sensor::location() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.location)
  return _internal_location();
}
inline void Sensor::unsafe_arena_set_allocated_location(
    ::nv::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Sensor.location)
}
inline ::nv::Location* Sensor::release_location() {
  
  ::nv::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Location* Sensor::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:nv.Sensor.location)
  
  ::nv::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::nv::Location* Sensor::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Location>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::nv::Location* Sensor::mutable_location() {
  ::nv::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:nv.Sensor.location)
  return _msg;
}
inline void Sensor::set_allocated_location(::nv::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.location)
}

// .nv.Coordinate coordinate = 5;
inline bool Sensor::_internal_has_coordinate() const {
  return this != internal_default_instance() && _impl_.coordinate_ != nullptr;
}
inline bool Sensor::has_coordinate() const {
  return _internal_has_coordinate();
}
inline void Sensor::clear_coordinate() {
  if (GetArenaForAllocation() == nullptr && _impl_.coordinate_ != nullptr) {
    delete _impl_.coordinate_;
  }
  _impl_.coordinate_ = nullptr;
}
inline const ::nv::Coordinate& Sensor::_internal_coordinate() const {
  const ::nv::Coordinate* p = _impl_.coordinate_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Coordinate&>(
      ::nv::_Coordinate_default_instance_);
}
inline const ::nv::Coordinate& Sensor::coordinate() const {
  // @@protoc_insertion_point(field_get:nv.Sensor.coordinate)
  return _internal_coordinate();
}
inline void Sensor::unsafe_arena_set_allocated_coordinate(
    ::nv::Coordinate* coordinate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coordinate_);
  }
  _impl_.coordinate_ = coordinate;
  if (coordinate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Sensor.coordinate)
}
inline ::nv::Coordinate* Sensor::release_coordinate() {
  
  ::nv::Coordinate* temp = _impl_.coordinate_;
  _impl_.coordinate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Coordinate* Sensor::unsafe_arena_release_coordinate() {
  // @@protoc_insertion_point(field_release:nv.Sensor.coordinate)
  
  ::nv::Coordinate* temp = _impl_.coordinate_;
  _impl_.coordinate_ = nullptr;
  return temp;
}
inline ::nv::Coordinate* Sensor::_internal_mutable_coordinate() {
  
  if (_impl_.coordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Coordinate>(GetArenaForAllocation());
    _impl_.coordinate_ = p;
  }
  return _impl_.coordinate_;
}
inline ::nv::Coordinate* Sensor::mutable_coordinate() {
  ::nv::Coordinate* _msg = _internal_mutable_coordinate();
  // @@protoc_insertion_point(field_mutable:nv.Sensor.coordinate)
  return _msg;
}
inline void Sensor::set_allocated_coordinate(::nv::Coordinate* coordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coordinate_;
  }
  if (coordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coordinate);
    if (message_arena != submessage_arena) {
      coordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:nv.Sensor.coordinate)
}

// map<string, string> info = 6;
inline int Sensor::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Sensor::info_size() const {
  return _internal_info_size();
}
inline void Sensor::clear_info() {
  _impl_.info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Sensor::_internal_info() const {
  return _impl_.info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Sensor::info() const {
  // @@protoc_insertion_point(field_map:nv.Sensor.info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Sensor::_internal_mutable_info() {
  return _impl_.info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Sensor::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Sensor.info)
  return _internal_mutable_info();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Place

// string id = 1;
inline void Place::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Place::id() const {
  // @@protoc_insertion_point(field_get:nv.Place.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Place::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Place.id)
}
inline std::string* Place::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nv.Place.id)
  return _s;
}
inline const std::string& Place::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Place::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Place::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Place::release_id() {
  // @@protoc_insertion_point(field_release:nv.Place.id)
  return _impl_.id_.Release();
}
inline void Place::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Place.id)
}

// string name = 2;
inline void Place::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Place::name() const {
  // @@protoc_insertion_point(field_get:nv.Place.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Place::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Place.name)
}
inline std::string* Place::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nv.Place.name)
  return _s;
}
inline const std::string& Place::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Place::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Place::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Place::release_name() {
  // @@protoc_insertion_point(field_release:nv.Place.name)
  return _impl_.name_.Release();
}
inline void Place::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Place.name)
}

// string type = 3;
inline void Place::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Place::type() const {
  // @@protoc_insertion_point(field_get:nv.Place.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Place::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Place.type)
}
inline std::string* Place::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:nv.Place.type)
  return _s;
}
inline const std::string& Place::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Place::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Place::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Place::release_type() {
  // @@protoc_insertion_point(field_release:nv.Place.type)
  return _impl_.type_.Release();
}
inline void Place::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Place.type)
}

// .nv.Location location = 4;
inline bool Place::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool Place::has_location() const {
  return _internal_has_location();
}
inline void Place::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::nv::Location& Place::_internal_location() const {
  const ::nv::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Location&>(
      ::nv::_Location_default_instance_);
}
inline const ::nv::Location& Place::location() const {
  // @@protoc_insertion_point(field_get:nv.Place.location)
  return _internal_location();
}
inline void Place::unsafe_arena_set_allocated_location(
    ::nv::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Place.location)
}
inline ::nv::Location* Place::release_location() {
  
  ::nv::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Location* Place::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:nv.Place.location)
  
  ::nv::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::nv::Location* Place::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Location>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::nv::Location* Place::mutable_location() {
  ::nv::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:nv.Place.location)
  return _msg;
}
inline void Place::set_allocated_location(::nv::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:nv.Place.location)
}

// .nv.Coordinate coordinate = 5;
inline bool Place::_internal_has_coordinate() const {
  return this != internal_default_instance() && _impl_.coordinate_ != nullptr;
}
inline bool Place::has_coordinate() const {
  return _internal_has_coordinate();
}
inline void Place::clear_coordinate() {
  if (GetArenaForAllocation() == nullptr && _impl_.coordinate_ != nullptr) {
    delete _impl_.coordinate_;
  }
  _impl_.coordinate_ = nullptr;
}
inline const ::nv::Coordinate& Place::_internal_coordinate() const {
  const ::nv::Coordinate* p = _impl_.coordinate_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Coordinate&>(
      ::nv::_Coordinate_default_instance_);
}
inline const ::nv::Coordinate& Place::coordinate() const {
  // @@protoc_insertion_point(field_get:nv.Place.coordinate)
  return _internal_coordinate();
}
inline void Place::unsafe_arena_set_allocated_coordinate(
    ::nv::Coordinate* coordinate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coordinate_);
  }
  _impl_.coordinate_ = coordinate;
  if (coordinate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Place.coordinate)
}
inline ::nv::Coordinate* Place::release_coordinate() {
  
  ::nv::Coordinate* temp = _impl_.coordinate_;
  _impl_.coordinate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Coordinate* Place::unsafe_arena_release_coordinate() {
  // @@protoc_insertion_point(field_release:nv.Place.coordinate)
  
  ::nv::Coordinate* temp = _impl_.coordinate_;
  _impl_.coordinate_ = nullptr;
  return temp;
}
inline ::nv::Coordinate* Place::_internal_mutable_coordinate() {
  
  if (_impl_.coordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Coordinate>(GetArenaForAllocation());
    _impl_.coordinate_ = p;
  }
  return _impl_.coordinate_;
}
inline ::nv::Coordinate* Place::mutable_coordinate() {
  ::nv::Coordinate* _msg = _internal_mutable_coordinate();
  // @@protoc_insertion_point(field_mutable:nv.Place.coordinate)
  return _msg;
}
inline void Place::set_allocated_coordinate(::nv::Coordinate* coordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coordinate_;
  }
  if (coordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coordinate);
    if (message_arena != submessage_arena) {
      coordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:nv.Place.coordinate)
}

// map<string, string> info = 6;
inline int Place::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Place::info_size() const {
  return _internal_info_size();
}
inline void Place::clear_info() {
  _impl_.info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Place::_internal_info() const {
  return _impl_.info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Place::info() const {
  // @@protoc_insertion_point(field_map:nv.Place.info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Place::_internal_mutable_info() {
  return _impl_.info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Place::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Place.info)
  return _internal_mutable_info();
}

// -------------------------------------------------------------------

// Message

// string messageid = 1;
inline void Message::clear_messageid() {
  _impl_.messageid_.ClearToEmpty();
}
inline const std::string& Message::messageid() const {
  // @@protoc_insertion_point(field_get:nv.Message.messageid)
  return _internal_messageid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_messageid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.messageid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Message.messageid)
}
inline std::string* Message::mutable_messageid() {
  std::string* _s = _internal_mutable_messageid();
  // @@protoc_insertion_point(field_mutable:nv.Message.messageid)
  return _s;
}
inline const std::string& Message::_internal_messageid() const {
  return _impl_.messageid_.Get();
}
inline void Message::_internal_set_messageid(const std::string& value) {
  
  _impl_.messageid_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_messageid() {
  
  return _impl_.messageid_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_messageid() {
  // @@protoc_insertion_point(field_release:nv.Message.messageid)
  return _impl_.messageid_.Release();
}
inline void Message::set_allocated_messageid(std::string* messageid) {
  if (messageid != nullptr) {
    
  } else {
    
  }
  _impl_.messageid_.SetAllocated(messageid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.messageid_.IsDefault()) {
    _impl_.messageid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Message.messageid)
}

// string mdsversion = 2;
inline void Message::clear_mdsversion() {
  _impl_.mdsversion_.ClearToEmpty();
}
inline const std::string& Message::mdsversion() const {
  // @@protoc_insertion_point(field_get:nv.Message.mdsversion)
  return _internal_mdsversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_mdsversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mdsversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Message.mdsversion)
}
inline std::string* Message::mutable_mdsversion() {
  std::string* _s = _internal_mutable_mdsversion();
  // @@protoc_insertion_point(field_mutable:nv.Message.mdsversion)
  return _s;
}
inline const std::string& Message::_internal_mdsversion() const {
  return _impl_.mdsversion_.Get();
}
inline void Message::_internal_set_mdsversion(const std::string& value) {
  
  _impl_.mdsversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_mdsversion() {
  
  return _impl_.mdsversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_mdsversion() {
  // @@protoc_insertion_point(field_release:nv.Message.mdsversion)
  return _impl_.mdsversion_.Release();
}
inline void Message::set_allocated_mdsversion(std::string* mdsversion) {
  if (mdsversion != nullptr) {
    
  } else {
    
  }
  _impl_.mdsversion_.SetAllocated(mdsversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mdsversion_.IsDefault()) {
    _impl_.mdsversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Message.mdsversion)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool Message::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Message::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Message::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Message::timestamp() const {
  // @@protoc_insertion_point(field_get:nv.Message.timestamp)
  return _internal_timestamp();
}
inline void Message::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Message.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:nv.Message.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:nv.Message.timestamp)
  return _msg;
}
inline void Message::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.timestamp)
}

// .nv.Place place = 4;
inline bool Message::_internal_has_place() const {
  return this != internal_default_instance() && _impl_.place_ != nullptr;
}
inline bool Message::has_place() const {
  return _internal_has_place();
}
inline void Message::clear_place() {
  if (GetArenaForAllocation() == nullptr && _impl_.place_ != nullptr) {
    delete _impl_.place_;
  }
  _impl_.place_ = nullptr;
}
inline const ::nv::Place& Message::_internal_place() const {
  const ::nv::Place* p = _impl_.place_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Place&>(
      ::nv::_Place_default_instance_);
}
inline const ::nv::Place& Message::place() const {
  // @@protoc_insertion_point(field_get:nv.Message.place)
  return _internal_place();
}
inline void Message::unsafe_arena_set_allocated_place(
    ::nv::Place* place) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.place_);
  }
  _impl_.place_ = place;
  if (place) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Message.place)
}
inline ::nv::Place* Message::release_place() {
  
  ::nv::Place* temp = _impl_.place_;
  _impl_.place_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Place* Message::unsafe_arena_release_place() {
  // @@protoc_insertion_point(field_release:nv.Message.place)
  
  ::nv::Place* temp = _impl_.place_;
  _impl_.place_ = nullptr;
  return temp;
}
inline ::nv::Place* Message::_internal_mutable_place() {
  
  if (_impl_.place_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Place>(GetArenaForAllocation());
    _impl_.place_ = p;
  }
  return _impl_.place_;
}
inline ::nv::Place* Message::mutable_place() {
  ::nv::Place* _msg = _internal_mutable_place();
  // @@protoc_insertion_point(field_mutable:nv.Message.place)
  return _msg;
}
inline void Message::set_allocated_place(::nv::Place* place) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.place_;
  }
  if (place) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(place);
    if (message_arena != submessage_arena) {
      place = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, place, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.place_ = place;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.place)
}

// .nv.Sensor sensor = 5;
inline bool Message::_internal_has_sensor() const {
  return this != internal_default_instance() && _impl_.sensor_ != nullptr;
}
inline bool Message::has_sensor() const {
  return _internal_has_sensor();
}
inline void Message::clear_sensor() {
  if (GetArenaForAllocation() == nullptr && _impl_.sensor_ != nullptr) {
    delete _impl_.sensor_;
  }
  _impl_.sensor_ = nullptr;
}
inline const ::nv::Sensor& Message::_internal_sensor() const {
  const ::nv::Sensor* p = _impl_.sensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Sensor&>(
      ::nv::_Sensor_default_instance_);
}
inline const ::nv::Sensor& Message::sensor() const {
  // @@protoc_insertion_point(field_get:nv.Message.sensor)
  return _internal_sensor();
}
inline void Message::unsafe_arena_set_allocated_sensor(
    ::nv::Sensor* sensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sensor_);
  }
  _impl_.sensor_ = sensor;
  if (sensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Message.sensor)
}
inline ::nv::Sensor* Message::release_sensor() {
  
  ::nv::Sensor* temp = _impl_.sensor_;
  _impl_.sensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Sensor* Message::unsafe_arena_release_sensor() {
  // @@protoc_insertion_point(field_release:nv.Message.sensor)
  
  ::nv::Sensor* temp = _impl_.sensor_;
  _impl_.sensor_ = nullptr;
  return temp;
}
inline ::nv::Sensor* Message::_internal_mutable_sensor() {
  
  if (_impl_.sensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Sensor>(GetArenaForAllocation());
    _impl_.sensor_ = p;
  }
  return _impl_.sensor_;
}
inline ::nv::Sensor* Message::mutable_sensor() {
  ::nv::Sensor* _msg = _internal_mutable_sensor();
  // @@protoc_insertion_point(field_mutable:nv.Message.sensor)
  return _msg;
}
inline void Message::set_allocated_sensor(::nv::Sensor* sensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sensor_;
  }
  if (sensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sensor);
    if (message_arena != submessage_arena) {
      sensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sensor_ = sensor;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.sensor)
}

// .nv.AnalyticsModule analyticsModule = 6;
inline bool Message::_internal_has_analyticsmodule() const {
  return this != internal_default_instance() && _impl_.analyticsmodule_ != nullptr;
}
inline bool Message::has_analyticsmodule() const {
  return _internal_has_analyticsmodule();
}
inline void Message::clear_analyticsmodule() {
  if (GetArenaForAllocation() == nullptr && _impl_.analyticsmodule_ != nullptr) {
    delete _impl_.analyticsmodule_;
  }
  _impl_.analyticsmodule_ = nullptr;
}
inline const ::nv::AnalyticsModule& Message::_internal_analyticsmodule() const {
  const ::nv::AnalyticsModule* p = _impl_.analyticsmodule_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::AnalyticsModule&>(
      ::nv::_AnalyticsModule_default_instance_);
}
inline const ::nv::AnalyticsModule& Message::analyticsmodule() const {
  // @@protoc_insertion_point(field_get:nv.Message.analyticsModule)
  return _internal_analyticsmodule();
}
inline void Message::unsafe_arena_set_allocated_analyticsmodule(
    ::nv::AnalyticsModule* analyticsmodule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.analyticsmodule_);
  }
  _impl_.analyticsmodule_ = analyticsmodule;
  if (analyticsmodule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Message.analyticsModule)
}
inline ::nv::AnalyticsModule* Message::release_analyticsmodule() {
  
  ::nv::AnalyticsModule* temp = _impl_.analyticsmodule_;
  _impl_.analyticsmodule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::AnalyticsModule* Message::unsafe_arena_release_analyticsmodule() {
  // @@protoc_insertion_point(field_release:nv.Message.analyticsModule)
  
  ::nv::AnalyticsModule* temp = _impl_.analyticsmodule_;
  _impl_.analyticsmodule_ = nullptr;
  return temp;
}
inline ::nv::AnalyticsModule* Message::_internal_mutable_analyticsmodule() {
  
  if (_impl_.analyticsmodule_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::AnalyticsModule>(GetArenaForAllocation());
    _impl_.analyticsmodule_ = p;
  }
  return _impl_.analyticsmodule_;
}
inline ::nv::AnalyticsModule* Message::mutable_analyticsmodule() {
  ::nv::AnalyticsModule* _msg = _internal_mutable_analyticsmodule();
  // @@protoc_insertion_point(field_mutable:nv.Message.analyticsModule)
  return _msg;
}
inline void Message::set_allocated_analyticsmodule(::nv::AnalyticsModule* analyticsmodule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.analyticsmodule_;
  }
  if (analyticsmodule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(analyticsmodule);
    if (message_arena != submessage_arena) {
      analyticsmodule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, analyticsmodule, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.analyticsmodule_ = analyticsmodule;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.analyticsModule)
}

// .nv.Object object = 7;
inline bool Message::_internal_has_object() const {
  return this != internal_default_instance() && _impl_.object_ != nullptr;
}
inline bool Message::has_object() const {
  return _internal_has_object();
}
inline void Message::clear_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
}
inline const ::nv::Object& Message::_internal_object() const {
  const ::nv::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Object&>(
      ::nv::_Object_default_instance_);
}
inline const ::nv::Object& Message::object() const {
  // @@protoc_insertion_point(field_get:nv.Message.object)
  return _internal_object();
}
inline void Message::unsafe_arena_set_allocated_object(
    ::nv::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Message.object)
}
inline ::nv::Object* Message::release_object() {
  
  ::nv::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Object* Message::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:nv.Message.object)
  
  ::nv::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::nv::Object* Message::_internal_mutable_object() {
  
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Object>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::nv::Object* Message::mutable_object() {
  ::nv::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:nv.Message.object)
  return _msg;
}
inline void Message::set_allocated_object(::nv::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.object)
}

// .nv.Event event = 8;
inline bool Message::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool Message::has_event() const {
  return _internal_has_event();
}
inline void Message::clear_event() {
  if (GetArenaForAllocation() == nullptr && _impl_.event_ != nullptr) {
    delete _impl_.event_;
  }
  _impl_.event_ = nullptr;
}
inline const ::nv::Event& Message::_internal_event() const {
  const ::nv::Event* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::nv::Event&>(
      ::nv::_Event_default_instance_);
}
inline const ::nv::Event& Message::event() const {
  // @@protoc_insertion_point(field_get:nv.Message.event)
  return _internal_event();
}
inline void Message::unsafe_arena_set_allocated_event(
    ::nv::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nv.Message.event)
}
inline ::nv::Event* Message::release_event() {
  
  ::nv::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nv::Event* Message::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:nv.Message.event)
  
  ::nv::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::nv::Event* Message::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::nv::Event>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::nv::Event* Message::mutable_event() {
  ::nv::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:nv.Message.event)
  return _msg;
}
inline void Message::set_allocated_event(::nv::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:nv.Message.event)
}

// string videoPath = 9;
inline void Message::clear_videopath() {
  _impl_.videopath_.ClearToEmpty();
}
inline const std::string& Message::videopath() const {
  // @@protoc_insertion_point(field_get:nv.Message.videoPath)
  return _internal_videopath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_videopath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.videopath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nv.Message.videoPath)
}
inline std::string* Message::mutable_videopath() {
  std::string* _s = _internal_mutable_videopath();
  // @@protoc_insertion_point(field_mutable:nv.Message.videoPath)
  return _s;
}
inline const std::string& Message::_internal_videopath() const {
  return _impl_.videopath_.Get();
}
inline void Message::_internal_set_videopath(const std::string& value) {
  
  _impl_.videopath_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_videopath() {
  
  return _impl_.videopath_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_videopath() {
  // @@protoc_insertion_point(field_release:nv.Message.videoPath)
  return _impl_.videopath_.Release();
}
inline void Message::set_allocated_videopath(std::string* videopath) {
  if (videopath != nullptr) {
    
  } else {
    
  }
  _impl_.videopath_.SetAllocated(videopath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.videopath_.IsDefault()) {
    _impl_.videopath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nv.Message.videoPath)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Embedding

// repeated float vector = 1 [packed = true];
inline int Embedding::_internal_vector_size() const {
  return _impl_.vector_.size();
}
inline int Embedding::vector_size() const {
  return _internal_vector_size();
}
inline void Embedding::clear_vector() {
  _impl_.vector_.Clear();
}
inline float Embedding::_internal_vector(int index) const {
  return _impl_.vector_.Get(index);
}
inline float Embedding::vector(int index) const {
  // @@protoc_insertion_point(field_get:nv.Embedding.vector)
  return _internal_vector(index);
}
inline void Embedding::set_vector(int index, float value) {
  _impl_.vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:nv.Embedding.vector)
}
inline void Embedding::_internal_add_vector(float value) {
  _impl_.vector_.Add(value);
}
inline void Embedding::add_vector(float value) {
  _internal_add_vector(value);
  // @@protoc_insertion_point(field_add:nv.Embedding.vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Embedding::_internal_vector() const {
  return _impl_.vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Embedding::vector() const {
  // @@protoc_insertion_point(field_list:nv.Embedding.vector)
  return _internal_vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Embedding::_internal_mutable_vector() {
  return &_impl_.vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Embedding::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:nv.Embedding.vector)
  return _internal_mutable_vector();
}

// map<string, string> info = 2;
inline int Embedding::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Embedding::info_size() const {
  return _internal_info_size();
}
inline void Embedding::clear_info() {
  _impl_.info_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Embedding::_internal_info() const {
  return _impl_.info_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Embedding::info() const {
  // @@protoc_insertion_point(field_map:nv.Embedding.info)
  return _internal_info();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Embedding::_internal_mutable_info() {
  return _impl_.info_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Embedding::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:nv.Embedding.info)
  return _internal_mutable_info();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nv

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_schema_2eproto
